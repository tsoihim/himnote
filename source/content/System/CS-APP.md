<aside> 📔 Computer Systems: A Programmer’s Perspective를 읽고

</aside>

## **5. 프로그램 성능 최적화하기**

### 5-1. 최적화의 장애물

- 포인터가 가리키는 메모리 위치
    ex) 두 개의 포인터를 인자로 받는 함수에서 컴파일러는 각 포인터가 어떤 값을 가지고 어떤 변수를 가리켜도 동일한 결과를 내도록 최적화를 해야함
- 함수 호출    
    컴파일러는 프로시저 호출에 관한 변환에 매우 조심스러움
    ex) 전역변수의 수정과 같은 side effect를 낳는 함수가 프로그램의 동작을 변경할 수 있게 될 때
- 컴파일러는 늘 최악의 경우를 가정. 어떻게 컴파일러의 작업을 단순화하면서 효율적인 코드를 짤까?
### 5-4. 루프 비효율성 제거
- code motion: 여러 번 수행하지만 계산 결과는 변하지 않는 계산을 찾아내는 것
    ex) 고정적인 값을 주는 함수를 루프에서 매 시행마다 호출할 필요는 없으나, 고정적인 값을 주는 함수를 컴파일러 입장에서 분별하기는 곤란함. 따라서 프로그래머 수준에서의 최적화가 필요
### 5-5. 프로시저 호출 줄이기
- 커스텀 데이터 타입을 다루기 위한 함수를 정의하고, 그 함수들로만 데이터를 다루는 것이 모듈화의 관점에서는 유용하지만 때로는 데이터타입 내부의 배열 등에 직접 접근하는 것이 효율적일 수도 있음
- 그럼에도 프로시저 내의 분기 예측 등이 연산과 함께 잘 수행될 수 있다면 성능 차이는 없다고 봐도 됨
### 5-6. 불필요한 메모리 참조 제거
- 누적값 계산 등 반복적인 작업을 포인터를 이용하여 구현하는 것보다, 임시로 사용할 지역변수를 선언하여 처리하는 것이 메모리 참조를 줄여 더 빠른 실행을 보장할 수도 있음
### 5-8. 루프 풀기
- 루프 배수를 늘려서 자체의 오버헤드를 줄이기 (“k x 1” 루프 풀기)
    작고 간결해야 효과를 보기 좋으며, 만능이 아님. 가독성도 나빠짐
### 5-9. 병렬성 높이기
- 순차 실행의 의존도가 높으면 결국 하드웨어의 지원을 fully 받지 못하므로 의존성 깨뜨릴 방법 필요
- “k x k” 루프 풀기
    교환 및 결합법칙이 작용할 수 있는 통합 연산을 여러 파트로 나누고 결과를 마지막에 합치는 방법
- 재결합 변환 (“k x 1a” 루프 풀기)
    산술연산을 재결합하여 병렬로 수행될 수 있는 연산의 수를 증가시킴
    ex) 의존성이 발생하는 연산의 괄호 순서만 변경하여도 “k x k” 루프 풀기의 효과를 얻을 수 있음
### 5-11. 여러가지 성능 제한 요인
- 레지스터 넘기기
    사용 가능한 레지스터의 수를 넘어가는 병렬성을 가질 때 컴파일러가 일부 임시 값을 메모리에 저장하는 방식으로 수행됨. 적당히 큰 k로 “k x k 루프 풀기” 구현했을 때 발생시켜볼 수 있음 -> 잘 발생하지는 않으나 발생하면 꽤 많은 비용이 들 듯
- 분기예측 오류를 최소화할 수 있는 방법
    1. 예측 가능한 분기에 대해서는 신경쓰지 말 것
    2. 분기 예측은 규칙적인 패턴에 대해서만 안정적임. 따라서 조건문 사용할 때 가능한 경우라면 컴파일러가 보다 조건부 데이터 이동을 사용할 수 있는 방법으로 작성
        - 조건부 데이터 이동이란 조건부 동작의 산출물 모두를 계산하고 조건에 따라 하나만 선택하는 방식 - jump vs cmov ([참고](https://koyo.kr/post/csapp-machine-level-control/))
### 5-12. 메모리 성능의 이해
- load/store
    store 자체는 완전히 파이프라인된 모드에서 동작 가능하지만 r/w 의존성이 생기는 로직이라면 성능을 저하시킴 (write한 값을 바로 다음에 read 하는 등)
### 5-13 테크닉
- 결국 잡기술보다 선행하는 알고리즘, 자료구조가 제일 중요
- 과도한 함수 호출 제거, 계산은 루프 밖에서, 모듈성과 성능 사이 균형점 추구
- 불필요한 메모리 참조 대신 지역변수 도입
- “k x k” 루프 풀기 등으로 인스트럭션 병렬성 높이기
- 조건부 데이터 이동 유도
### 5-14 프로파일링
- gcc -pg, valgrind 써보기

## **6. 메모리 계층구조**
### 6-2. 지역성
- 프로그램 데이터의 지역성, 인스트럭션의 지역성
- 공간/시간 지역성
- 캐시 히트 확률이 올라감
- stride-1 참조 패턴이 좋은 이유
### 6-5. 캐시 친화적 코드 작성하기
1. 공통적인 경우를 빠르게 동작하도록 만들기 - 핵심 함수들의 내부 루프에 집중
2. 각 내부 루프의 캐시 미스를 최소화하기 - load와 store의 총량이 같다는 등
    - 지역변수는 대부분 메모리 구조 최상위에 존재하게 됨

## **7. 링커**

### 7-3. 목적파일
- 어셈블러는 컴파일러가 변환한 각 파일의 어셈블리 코드에 대해 재배치가능 목적파일을 생성, 링커는 이들 모두를 연결 및 바이너리 재배치해 실행가능 목적파일로 만들어 로더가 실행할 수 있도록 만듬
- 목적파일에는 한가지 형태가 더 있는데 공유 목적파일임. 로드 및 런타임 시에 동적으로 링크되고 메모리에 로드될 수 있음
### 7-4. ELF
- 리눅스에서 위 목적파일들은 아래와 같은 ELF 포맷으로 다루어짐
	![[Pasted image 20250501194509.png|500]]
### 7-6. 심볼 해석
- global, static 변수의 차이 및 static 함수
- 컴파일러는 알 수 없는 참조 심볼에 대해서는 링커가 처리할 수 있게 내비둠. 단, 중복되는 전역 심볼의 처리에 대해서는 시스템마다 다를 수 있고 위험
- 정적 라이브러리
    > On Linux systems, static libraries are stored on disk in a particular file format known as an _archive_. An archive is a collection of concatenated relocatable object files, with a header that describes the size and location of each member object file
- 링크 커맨드에 라이브러리 및 목적파일 순서 배치 중요함, 라이브러리를 보통 뒤로 둔다
- 의존성에 따라 라이브러리의 입력 순서변경 및 반복 입력도 필요
### 7-7. 재배치
1. 섹션 및 심볼 정의 재배치 -> 목적파일들의 같은 섹션들을 통합해 하나의 섹션으로 만든다
    이때 모든 인스트럭션, 심볼들이 유일한 런타임 메모리 주소를 할당받음
2. 섹션 내 심볼 참조 재배치
    모든 심볼 참조를 수정해서 정확한 런타임 주소를 가리키도록 함. 이를 위해 재배치 가능 목적 모듈 내부의 재배치 엔트리(rel.text, rel.data에 있음)라고하는 자료구조를 사용
### 7-10. 공유 라이브러리로 동적 링크하기
- 공유 라이브러리(.so)는 런타임이나 로드타임에 임의의 메모리 주소에서 로드되고, 메모리에서 프로그램으로 연결될 수 있는 목적 모듈 (동적 링커라고 하는 프로그램에 의해 수행)
- 공유 라이브러리는 두가지 방법으로 공유됨
    1. 특정 라이브러리별로 하나의 .so가 존재, 이 .so 파일 내의 코드 및 데이터는 이 라이브러리를 참조하는 모든 실행 가능 목적파일에 의해 공유됨(참조하는 파일들로 복사가 일어나지 않음)
    2. 메모리에 있는 공유 라이브러리의 .text 섹션을 서로 다른 실행 프로세스가 공유
- .so 파일과 연결하여 실행가능 목적 파일을 만들면, 링킹의 일부는 정적으로 수행되고 프로그램이 로드될 때 링킹작업이 동적으로 완료됨
    *실제 실행 가능 목적파일에는 .so의 코드 및 데이터가 복사되지 않음, 일부 재배치 및 심볼 테이블 정보만 복사되어 공유 라이브러리에 대한 참조가 로드타임에 해결될 수 있음
- 최종 실행 가능 목적파일은 .interp 섹션을 포함하게 됨. 이 섹션에 동적 링커 정보가 있는데 얘조차도 이미 동적 객체임. 따라서 로더는 먼저 동적 링커를 로드/실행 후 응용에 제어 넘김
- 런타임에 공유 라이브러리를 로드하고 링크할 수도 있음
### 7-12. 위치 독립성 코드(PIC)
- 어떻게 다수의 프로세스들이 하나의 동적 라이브러리 사본을 공유하는지
- 현대 시스템에서는 공유 모듈 코드 일부분을 컴파일하여 링커에 의해 수정되지 않고도 메모리 어디든지 로드될 수 있도록 함. 즉, 재배치 작업 없이 로드될 수 있는 코드임
- 공유 객체가 정의한 외부 프로시저 및 전역변수를 참조할 때 PIC 데이터 참조라는 테크닉을 사용
    - PIC 데이터 참조
        한 모듈에서 데이터 및 코드 세그먼트의 상대적 거리는 동일하므로, 컴파일러는 공유 객체 참조하는 각 모듈의 데이터 세그먼트에 전역 오프셋 테이블(GOT)을 생성. GOT는 해당 모듈이 참조하는 각 전역 오브젝트에 대한 엔트리를 가짐. 컴파일러는 각 엔트리에 대해 재배치 레코드를 생성, 동적 링커는 각 엔트리를 재배치해서 오브젝트 절대주소를 포함시킴
    - 그렇다면 어떻게 GOT를 통한 간접접근이 가능한가?
        GOT 및 PLT를 통해서 메모리 내에 하나만 존재하는 라이브러리 메모리로 점프하는 건가? 그러면 라이브러리 데이터는 어떻게 메모리 내에서 관리되나?
7.12부터는 나중에 다시보기

## **8. 예외적인 제어흐름 (ECF)**
어플리케이션은 트랩 또는 시스템콜이라고 하는 ECF의 한 가지 형태를 사용하여 OS에 서비스 요청가능
ECF는 동시성 구현의 기본 메커니즘이 됨, try catch와 같은 비지역성 점프 또한 ECF
이 장부터는 어플리케이션과 OS의 상호작용을 다룸, 물론 ECF는 모든 수준에서 존재
### 8-1. 예외
- 예외 상황은 어떤 프로세서 상태의 변화에 대한 대응으로 제어흐름의 갑작스런 변화
- 단순 에러, I/O 요청 등의 이벤트가 발생하면 프로세서가 이를 감지해 예외 테이블이라고 하는 점프 테이블을 통해 해당 이벤트를 처리하기 위해 설계된 OS의 서브루틴; 예외처리 핸들러로 간접 프로시저 콜을 하게 됨
- 예외처리 핸들러가 처리를 마치면 예외상황을 발생시킨 이벤트 종류에 따라 다음 셋으로 분기
    1. 이벤트 발생 시 실행중이었던 인스트럭션으로 제어 돌려줌
    2. 제어를 다음 인스트럭션으로 돌려줌(이벤트와 무관하게 실행되었을 녀석)
    3. 중단된 프로그램을 종료
- 예외처리 방식
    - 한 시스템에서 예외상황별로 양의 정수가 할당되고 이는 프로세서 설계자 및 OS가 각각 부여. 부팅 시에 예외 테이블이 초기화 및 설정되고 이벤트 발생 시 예외 테이블 참고해서 예외 핸들러 주소로 점프(예외번호는 예외 테이블에서의 인덱스)
    - 프로세서는 핸들러로 분기하기 전 리턴 주소, 중단된 프로그램을 다시 시작하기 위해 필요한 추가적인 프로세서 상태를 스택에 푸시
    - 제어가 어플리케이션에서 커널로 전환 중에는 이 모든 아이템이 커널 스택 상에 푸시됨
    - 예외 핸들러는 커널 모드에서 돌아감
    - 예외 핸들러는 예외 처리 후 특별한 인스트럭션을 실행시켜서 중단된 프로그램으로 돌아갈 수 있고 이 인스트럭션은 필요한 제어 및 데이터 레지스터 상태 등을 스택으로부터 팝해서 돌려주고 사용자 프로그램인 경우 사용자 모드로 되돌려주는 등의 작업 가능
- 예외의 종류
    - 인터럽트: 프로세서 외부의 I/O 디바이스의 시그널에 의해 비동기적으로 발생. 현재 인스트럭션 실행 완료 후 인터럽트 신호가 오면 예외처리 수행. 핸들러 리턴 시에는 이벤트와 무관하게 다음에 왔어야할 인스트럭션으로 제어 넘어감. 다른 종류는 모두 동기(인스트럭션에 의해 발생)
    - 트랩: 의도적 예외상황. 제어 리턴은 인터럽트와 같음. 사용자 프로그램(사용자 모드에 있어서 제한된 인스트럭션만 수행 가능)이 사용하는 시스템 콜이 가장 중요한 사용처.
    - fault: 핸들러가 정정할 수 있을 가능성이 있는 에러 조건으로부터 발생. 오류 핸들러가 에러 조건을 정정할 수 있으면 오류 발생된 인스트럭션으로 제어가 돌아감(ex. 페이지 오류 예외). 안되면 abort 루틴으로 전환
    - abort: x된 상황. 예외 핸들러는 제어를 응용프로그램의 중단 루틴으로 넘김
### 8-2. 프로세스
- 예외상황은 프로세스 개념을 커널이 제공할 수 있게 하는 기본 구성 블록
- 프로세스 하나가 프로세서를 독점하는 것처럼 보이게 하는 것
- 논리적인 제어흐름
    - 프로그램 내의 인스트럭션에 PC 값(실행할 명령어 주소)이 대응되며 이 값의 배열
- 동시성 흐름
    - 논리 흐름들이 시작해서 종료하는 시간이 겹치는 경우
- 사적 주소공간
    - 프로세스는 각 프로그램에 사적 주소공간을 제공(자기만 참조 가능)
- 사용자 및 커널모드
    - 제어 레지스터로 모드 비트가 설정되면 프로세스는 커널 모드로 동작하면서 모든 인스트럭션 수행이 가능해짐
- 문맥 전환
    - 커널은 각 프로세스마다 프로세스를 다시 시작하기 위해 필요한 컨텍스트(PC, 레지스터, 사용자/커널 스택 등)를 유지
    - 커널은 프로세스를 스케줄링 가능(문맥 저장 -> 문맥 복원 -> 제어 전달)
    - 문맥 전환은 시스템 콜, 시스템 내부 타이머 인터럽트 등 다양한 상황에서 실행됨
*에러 처리 위해 래퍼함수 써서 Unix 시스템 수준 함수가 에러 발견 시 리턴하는 errno 체크하도록하면 좋음
### 8-4. 프로세스의 제어
- 프로세스 상태
    - 실행 중: 실행되고 있거나 실행 중(스케줄링)
    - 정지: 시그널 받아서 정지 상태로 남아있다가 SIGCONT 받으면 다시 실행
    - 종료: 프로세스는 영구적으로 정지(종료 시그널, 메인 루틴 리턴, exit로 인해)
- fork
    - 부모 프로세스가 자식 프로세스를 생성
    - 자식은 부모의 거의 모든 것을 복사해서 가지게 됨 (fd도 같은 곳 가리킴)
    - fork 함수는 부모에서 한 번, 자식에서 한 번씩 리턴하는 특성 있음(부모에서는 자식의 PID, 자식에서는 0)
    - 공유된 파일 사용 (부모 자식 모두의 출력이 쉘에 출력되는 것은 같은 stdout 파일을 사용 중이기 때문)
- 자식 청소
    - 커널은 종료된 프로세스를 즉시 종료하지 않음. 부모가 청소할 때까지 자식은 남아있고 청소할 때 커널은 자식의 exit 상태를 부모에게 전달, 그 후 종료된 프로세스를 없앰(종료되었으나 청소되지 않은 프로세스 = 좀비)
    - 고아가 된 자식의 경우 init에게 입양
    - 쉘, 서버와 같이 오래도록 실행되는 프로그램의 경우 청소를 잘해줘야함
    - waitpid 함수를 통해서 자식의 종료/정지를 기다릴 수 있음
        - pid_t waitpid(pit_t pid, int *startup, int options);
        - 기본 옵션(=0)일 때 대기 집합 내 한 자식 프로세스가 종료할 때까지 부모 정지시킴
        - 반환값은 종료된 자식의 PID이며 이 지점에서 종료된 자식은 시스템에서 삭제됨
        - 대기집합은 pid 값 설정에 따라 달라짐
        - startup 인자가 NULL이 아니면 해당 인자를 통해 청소된 자식의 exit 상태 체크가능
        - 호출하는 프로세스가 자식이 없거나 waitpid 자체가 시그널 맞고 중단되면 -1 리턴
    - sleep 함수
        - 일정 기간 동안 프로세스 정지. 요청한 시간이 경과하면 0 리턴 아니면 남은 시간 동안 정지
    - pause 함수
        - 시그널 받을 때까지 프로세스 정지
    - exec 계열 함수
        - 현재 프로그램 컨텍스트에서 아예 새로운 프로그램 로드 및 실행하도록함
        - 프로세스가 하나 더 생성되는 것이 아니라 새 프로그램으로 덮어써버림
        - 따라서 obboot의 경우 fork 뜬 다음 자식 프로세스에서 exec 호출
        - 여러 접미사가 붙어 입맛에 맞게 쓸 수 있음
        - 현재 프로그램 컨텍스트에서 새로운 프로그램 로드 및 실행하도록함
        - 실행가능 목적파일, arg, env 전달 받아서 프로그램 실행하며 에러 없으면 리턴안함
        - 세션에 대하여 확인
### 8-5. 시그널
상위 수준에서의 예외적 제어흐름, 프로세스와 커널이 다른 프로세스를 중단하도록 함
- 시그널은 작은 메시지 형태로, 프로세스에게 시스템에서 어떤 이벤트가 발생했다는 것을 알려줌
- 하위수준 하드웨어 예외와 같이 사용자 프로세스에서 볼 수 없는 예외들을 노출시켜줌
- 시그널 용어
    - 커널은 프로세스 컨텍스트 내에 있는 상태를 변경하는 것으로 시그널을 전달
        1. dividebyzero나 자식의 종료와 같은 시스템 이벤트 감지로 발생
        2. 어떤 프로세스가 명시적으로 목적 프로세스에 시그널 보내려고 kill함수 호출
    - 프로세스는 시그널 핸들러라고 부르는 사용자 함수 정의해서 시그널 처리할 수 있음
        시그널은 타입별로 최대 한개만 펜딩되며, 이외에는 버려짐
        프로세스는 시그널을 블록할 수도 있는데, 프로세스가 블록 풀어줄 때까지는 해당 펜딩 시그널을 수신할 수 없음
        커널은 각 프로세스에 대해 pending 및 blocked 비트 벡터 내에서 시그널 집합 관리![[스크린샷 2025-05-01 19.50.12.png|500]]
- 시그널 보내기 (시그널을 프로세스로 보내는 메커니즘)
    - 유닉스는 각 프로세스마다 단 하나씩 가지는 프로세스 그룹 개념을 사용
    - 기본적으로 자식이랑 부모는 같은 그룹, 물론 자신 및 다른 프로세스의 그룹 변경 가능
    - 쉘에서 | 로 명령어 파이프 사용
        - 명령어 별 프로세스가 같은 그룹으로 생성됨(포그라운드 작업으로)
        - ctrl + c/z 입력하면 SIGINT/SIGSTP가 해당 프로세스 그룹의 모든 프로세스로 전달됨
    - 프로세스는 kill 함수 호출해서 시그널을 목적 프로세스로 전송 가능
        - pid 0으로 설정하면 그룹 내 모든 프로세스에 전달
        - (-1)은 전송 가능한 모든 프로세스에, -1 보다 작으면 그룹(|pid|) 내 모든 프로세스에 전달
    - alarm 함수쓰면 특정 주기로 커널이 자신에게 시그널 쏘게 할 수 있음
        - 어떤 이벤트가 발생하던 간에, alarm 호출하면 대기하던 모든 알람 취소하고, 대기 alarm이 전달되었어야 할 때까지 나은 시간을 반환 혹은 없으면 0 반환
- 시그널 수신하기
    - 프로세스 p를 커널 모드에서 사용자모드로 전환 시, 커널은 논블록인 펜딩 시그널 집합 확인해 펜딩 시그널 전달(보통 최소 k 먼저), 비어있으면 다음 진행될 인스트럭션에 제어 전달
    - 프로세스는 시그널 맞으면 사전에 정의된 동작을 하게되고 완료 후에 다음 인스트럭션으로 제어가 돌아가거나 시그널에 대응하는 동작에 따라 처리됨
        - 시그널 타입에 따라 기본 동작은 프로세스를 종료하거나 중지시키거나 시그널 무시 가능
        - SIGSTOP과 SIGKILL은 핸들러로 동작 변경 불가
        - 이외에는 시그너 함수를 통해 사용자가 정의한 함수로 기본 동작을 수정할 수 있음 (핸들러를 설치한다고 하며, 해당 사용자 정의 함수의 주소를 signal 함수로 넘겨줌)
        - 시그널은 핸들러 포인터 혹은 에러 시 SIG_ERR 반환
    - 시그널 핸들러도 다른 핸들러에 의해 중단될 수 있음
- 시그널 블록 및 해제
    - 시그널의 펜딩 또한 커널에 의한 implicit 블로킹임
    - 어플리케이션은 sigprocmask 함수 통해 명시적으로 특정 시그널을 블록할 수 있음
        - sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
        - 현재 블록 중인 시그널 집합을 변경할 수 있음
        - how 값을 통해 set을 블록할지 언블록할지 등 정함
        - sigset 계열 함수 통해 signal set을 다룰 수 있음
- 시그널 핸들러 사용하기
    - 시그널 핸들러 작성이 까다로운 이유
        핸들러는 메인 프로그램과 전역 변수를 공유하며 concurrent하게 돌아감시그널이 언제 어떻게 수신되는 지에 대한 규칙이 때로 비직관적임
    - 안전한 시그널 핸들러 작성법
        - 최대한 간단히 작성 (ex. 핸들러는 flag만 set, 실질적 처리는 flag 기반 외부 처리)
        - 핸들러 내부 함수는 reentrant하거나 핸들러에 의해 인터럽트 되지 않는 safe한 녀석으로만. output 낼 수 있는 함수 중 안전한 놈은 write 함수 밖에 없음
이후 파트 나중에

## **9. 가상 메모리**
가상 메모리는 메인 메모리의 추상화, 프로세스 하나가 메인메모리를 독점하는 것처럼 보이게함
1. 메인 메모리를 캐시로 취급해 메인 메모리 내 활성화 영역만 유지, 필요에 따라 디스크서 데이터 get
2. 각 프로세스에 통일된 주소공간 제공
3. 각 프로세스 공간을 외부에 의한 손상으로부터 보호
가상 메모리 통해 어플리케이션에 메모리 블록 생성/삭제하고, 메모리 블록을 디스크 파일 부분으로 매핑하고, 메모리를 타 프로세스와 공유하는 등의 강력한 기능을 사용 가능 (ex. 메모리 위치에서 r/w로 디스크 파일 내용을 수정할 수 있으며 파일 내용을 메모리로 명시적 복사를 하지 않고도 로드 가능) 하지만 잘 모르고 쓰면 그만큼 위험할 수 있으므로 malloc 패키지부터 시작해 어떻게 가상메모리 잘 사용할 수 있는지 알아야함
	![[Pasted image 20250501195625.png|500]]
### 9-1. 물리 및 가상주소 방식
- 메인 메모리는 M개의 연속 바이트로 구성, 각 바이트는 고유 물리주소가 있음
- 가상주소 방식에서 CPU는 가상 주소로 데이터 요청, MMU가 이를 물리주소로 변환해줌
### 9-3. 캐시로서의 VM
- 결론적으로 VM은 N개의 바이트 크기의 셀 배열로 구성되며 각 바이트는 배열 인덱스로 작용하는 특정한 가상주소 가짐
- 메인 메모리와 디스크 사이 캐시는 블록단위로 분할, VM도 블록 단위로 분할(가상페이지)되어 관리됨
- 가상페이지 집합의 partition은 unallocated, cached, uncached로 나뉨
- 페이지 테이블(프로세스별 존재하는 dram에 저장된 자료구조)은 가상 페이지를 물리 페이지로 매핑
    페이지 테이블과 MMU의 조합으로 가상 페이지가 DRAM 어디에 캐시되었는지 결정, 어떤 물리 페이지를 캐싱했는지, 미스 발생 시 디스크 어디에 가상페이지가 있으며 victim 페이지 선택 및 가상페이지를 디스크에서 DRAM으로 복사해 victim 페이지 교체
### 9-4. 메모리 관리도구로서의 VM
- 다수의 가상페이지들은 동일한 공유 물리 페이지에 매핑될 수 있음
- 프로세스가 물리 메모리 어디에 적재되던간에 통일된 메모리 포맷을 가지게 됨
- 로딩의 단순화
    - 리눅스 로더는 .data, .text 섹션을 새롭게 생성된 프로세스에 로드하기 위해서 가상 페이지 할당하고, 이들의 페이지 테이블 엔트리를 목적파일의 해당 위치만 가리키게함
        → 이처럼 연속된 가상페이지를 임의의 파일 내의 임의의 위치로 매핑하는 것이 메모리 매핑
    - 결국 실제로 디스크로부터 메모리로 데이터는 전혀 복사되지 않은 것임(page fault 전까진)
- 공유 단순화: 커널 코드, 표준 라이브러리 루틴 등을 쉽게 공유 가능
- 메모리 할당 단순화
    - 응용이 malloc 등으로 추가적인 힙 공간 요청하면, OS는 단순히 k개의 연속적인 가상메모리 페이지를 할당하고 각각 물리페이지로 매핑, 각 페이지는 물리 메모리 내에 랜덤하게 흩어짐
*리눅스에서 seg fault -> 잘못된 주소 혹은 방식으로 메모리 접근 시 발생
리눅스는 연속되는 가상페이지 집합을 연속되는 물리페이지 집합으로 매핑함
리눅스는 세그먼트의 집합으로 가상메모리를 구성하며 한 세그먼트(영역)는 가상메모리의 연속된 묶음으로 힙, 사용자 스택 등을 각각 영역으로 볼 수 있음(가상페이지는 늘 특정 영역에 포함됨)
### 9-8. 메모리 매핑(다시 읽기)
- 리눅스는 세그먼트의 내용을 디스크의 객체에 연결해서 초기화하며 이 과정이 메모리 매핑
- 세그먼트는 다음 두 객체; 일반 파일 혹은 무기명 파일 중 하나로 매핑됨
    - 무기명 파일은 커널이 만든 것, 전체가 0의 값을 가짐
    - malloc 등 파일에 사본이 없는 데이터를 위한 것 같은데 잘 모르겠음
- 가상 페이지가 초기화된 경우에는 어떤 경우든지 커널이 관리하는 스왑 파일 사이에서 스왑 인 되었다가 아웃되었다가를 반복함
    - 스왑 파일은 스왑 공간 또는 스왑 영역이라 함
    - 어느 시점에, 스왑 공간이 동시실행되는 프로세스에 의해 할당된 전체 가상페이지 양을 제한
- 공유 객체
    - 메모리 매핑 통해 물리 메모리에 있는 공유 객체 데이터를 공유 가능
    - 디스크 객체는 세그멘트에 공유 객체 또는 private 개체로 매핑됨
        - 공유 객체를 프로세스 자신의 공유 주소공간으로 매핑하면 이 영역에 쓰는 모든 내용은 자신의 공유 메모리 내로 객체를 매핑한 다른 프로세스도 볼 수 있음
        - private 객체에 매핑된 영역의 수정사항들은 다른 프로세스가 볼 수 없고, 이 영역에 프로세스가 수행한 모든 쓰기 작업은 디스크 상의 객체에는 반영되지 않음
    - write는 cow 방식으로 수행, write할 때만 물리메모리에 객체 사본을 생성하고 해당 사본으로 매핑 변경
### 9-9. 동적 메모리 할당
- 런타임에 malloc 등을 이용하여 heap 메모리를 동적으로 할당받을 수 있음
    - sbrk 함수로 힙 꼭대기 가리키는 brk 변수 늘리거나 줄일 수도 있음
- 힙은 다양한 크기의 블록 집합으로 관리됨, 각 블록은 할당되었거나 가용한 가상메모리의 연속적 묶음
- 묵시적 할당기를 가비지 컬렉터라고 보면 됨
    - unreachable한 블록들을 반환시키는 것
- malloc(k) 함수는 최소 k 바이트를 갖는 메모리 블록의 포인터를 리턴
    - free 함수의 포인터 인자와 같이 메모리 블록의 시작을 가리킴
- 가상메모리 크기도 스왑 공간에 의해 제한되므로 유의 필요
- 좋지 않은 힙 이용/정책에 의해, 가용 메모리가 할당 요청을 처리하기에 충분하지 않으면 단편화 발생
    - 내부 단편화는 할당 블록이 데이터 자체보다 클 때 발생
    - 외부 단편화는 할당 요청을 처리할 충분히 큰 하나의 가용 블록이 없을 때 발생
    - 할당기는 블록을 가용/할당블록으로 나누어 관리, 여러 가용 리스트 관리방식 존재
### 9-11. 어플리케이션에서 메모리 관련 주의사항
- 스택 오버플로우를 허용하는 것
    - 표준입력으로 받은 스트링 등의 데이터는 언제나 길이를 조사하여야 함
- 포인터와 데이터 타입을 같은 크기라고 가정하는 것
- C 연산자 순서 및 결합을 잘못 작성하여 변수 값 대신 포인터 주소에 대한 연산을 하는 것
- 포인터 연산은 바이트 단위가 아닌 가리키는 객체 크기 단위로 수행됨
- 스택 프레임에 대한 이해없이 포인터를 사용하는 것
    → 반환된 함수에서 발생한 포인터가 다른 함수 스택 프레임에 개입할 여지 발생
- 이미 반환한 힙 블록 내 데이터 참조하거나 free 빼먹어서 메모리 leak 발생시키는 것

## **10. 시스템 수준 입출력**
모든 I/O 디바이스들은 파일로 모델링되며 이를 읽고 쓰는 식으로 입출력이 수행됨
### 10-1. Unix I/O
- 리눅스 커널은 디바이스에서 파일로 매핑하며 Unix I/O라는 간단한 응용 인터페이스 제공
    - 파일 열기 -> 인터페이스가 fd 반환
    - 파일 내 위치 변경 -> 시작은 0, seek 연산 수행하여 명시적으로 offset 설정 가능
    - 파일 r/w -> 디스크에서 메모리로 파일 복사(EOF 나올 때까지)
    - 파일 닫기 -> 커널이 파일 열면서 발생한 자료구조와 사용한 fd 반환
### 10-2. 파일
- 파일 타입
    - 일반 파일
    - 디렉토리 : 링크들의 배열(디렉토리나 파일 이름을 각 디렉토리나 파일로 대응시킴)
    - 소켓 : 네트워크 상의 다른 프로세스와 통신하기 위해 사용
### 10-3. 파일 열고 닫기
- open 함수
    - 프로세스가 위 함수 호출하여 기존 파일 열거나 생성 가능, fd 반환함
    - 파일네임, r/w 모드 및 정책, 권한 등의 설정을 인자로 전달
    - 파일 닫을 때는 fd를 인자로 넘겨서 close 함수 호출
### 10-4. 파일 읽기와 쓰기
- read 함수
    - fd의 현재 파일 위치에서 최대 n 바이트를 메모리 위치 buf로 복사 (fd, buf, n이 인자)
- write 함수
    - 메모리 위치 buf에서 fd의 현재 파일 위치로 최대 n 바이트 복사
- 만약 읽는 도중 EOF를 만나면 n보다 작은 카운트를 가지게 될 것임
- 터미널에서 텍스트 줄 읽거나 네트워크 소켓 읽고 쓸 때도(버퍼링 제약/레이턴시에 기인) 마찬가지
- lseek 함수 통해 파일 위치 변경 가능
### 10-6. 파일 메타데이터 읽기
- 응용에서 stat 혹은 fstat 호출하여 가져올 수 있음
- stat/fstat에 filename/fd와 stat 구조체 포인터를 인자로 전달하여 메타데이터를 가져옴
### 10-7. 디렉토리 내용 읽기
- opendir : 디렉토리 스트림을 가리키는 포인터 리턴
- readdir : 디렉토리 스트림에서 다음 디렉토리 항목으로의 포인터를 리턴
    - 해당 포인터가 가리키는 구조체에 inode 및 파일네임 존재
- closedir: 스트림 닫고 자신의 자원 반환
### 10-8. 파일 공유
- 커널은 세 가지의 자료구조로 오픈한 파일들을 표현
    - 식별자 테이블
        - 각 프로세스는 자신만의 식별자 테이블을 가지며 이를 각 파일 테이블 엔트리에 매핑
    - 파일 테이블
        - 모든 프로세스가 공유, 각 엔트리는 파일 위치/fd 참조 수/v-노드 엔트리로의 포인터로 구성
        - fd 닫으면 참조 수가 하나씩 줄고, 파일 테이블 엔트리는 참조 수가 0이 되기 전까지 유지됨
    - v-노드 테이블
        - 모든 프로세스가 공유, 각 엔트리는 stat 구조 내의 대부분의 정보를 가짐
- 한 프로세스에 대해서, 한 파일 당 유일한 fd가 존재하는 건 아님. open 여러 번 호출하면 여러 fd와 파일 테이블 엔트리가 생기고 최종적으로 유일한 v-노드 테이블을 가리키게 됨
    ![[Pasted image 20250501195846.png|500]]
- fork 뜨면 상기와 같은 방식으로 파일이 공유되는 것
### 10-9. I/O 재지정
- 쉘에서 > 쓰면 표준출력이 파일로 써짐
- dup2 함수 같은 애들이 이걸 해줌. 얘는 old/new fd를 받아서 old를 닫고 new fd가 가리키는 파일 테이블로 매핑을 변경해줌. 따라서 이후 발생하는 표준출력은 파일로 써지는 거임
### 10-10. 표준 I/O
- C 표준 I/O 라이브러리는 Unix I/O의 고급 대체 함수 제공
- 오픈 파일을 스트림으로 모델링하는 방식 사용, 스트림은 FILE 타입 갖는 구조체로의 포인터
- FILE 타입의 스트림은 fd와 스트림 버퍼에 대한 추상화임
    - 스트림 버퍼는 시스템 콜을 최소화하고 데이터 전송을 효율적으로 할 수 있게해줌
    - 예를 들어, 단어를 입력받을 때 한 문자씩 반복해서 가져올 필요는 없기 때문
    - 표준I/O의 제약으로 인해 소켓에서의 입출력 용도로는 안쓸 것을 권장

## **11. 네트워크 프로그래밍**
모든 I/O 디바이스들은 파일로 모델링되며 이를 읽고 쓰는 식으로 입출력이 수행됨
### 11-2. 네트워크 구성
- 호스트 입장에서 네트워크는 또 다른 I/O 디바이스임
### 11-3. 글로벌 IP 인터넷
- 클라이언트와 서버는 소켓 인터페이스와 Unix I/O 함수들의 혼합을 이용해 통신
- 소켓 함수들은 일반적으로 시스템 콜로 구현되어 커널에서 트랩을 발생시킴
- 네트워크 바이트는 빅 엔디안이(큰 자리수가 작은 주소값에 존재)므로 리틀에서는 변경 필요
    - htonl 등의 함수 사용
- IP 주소와 스트링 간의 변환은 inet_pton 등의 함수 사용
- 도메인 네임의 계층 순서는 네임 뒤에서부터 따짐(com -> google -> www)
    - nslookup 커맨드로 도메인에 대응하는 ip 출력 가능
- 클라이언트와 서버는 연결을 통해 바이트 스트림을 주고받는 방식으로 통신(proc to proc)
    - 소켓은 연결의 종단점으로, 인터넷 주소와 16비트 정수 포트로 이루어진 소켓 주소 가짐
        → 따라서 연결은 두 소켓 주소에 의해 유니크하게 결정됨
    - 클라이언트의 포트는 커널이 자동 할당(ephemeral), 서버는 보통 서비스별 고정 포트 사용
### 11-4. 소켓 인터페이스
- 네트워크 응용을 만들기 위한 Unix I/O 함수들과 함께 사용되는 함수들의 집합
- Unix 관점에서 소켓은 식별자를 가지는 열린 파일
- 소켓 주소는 sockaddr_in 타입의 16바이트 구조체에 저장됨 (포트, IP는 항상 빅 엔디안으로!)
- 소켓 관련 함수는 이 소켓 주소 구조체를 가리키는 void * 포인터(임의의 대상체 모두 가리킴)를 사용
    - 캐스팅 필요 x, 반대로 임의의 포인터에 void 포인터 대입할 때는 캐스팅 필수
    - 아래 그림의 sockaddr_in이 최종적으로 sockaddr로 캐스팅됨
		![[Pasted image 20250501200103.png|500]]
- socket(int domain, int type, int protocol)
    - 소켓 fd를 생성하는 함수, fd 값 반환함
    - 아직은 fd에 읽고 쓸 수 없으며 클라이언트/서버에 따라 추가작업 필요
- connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen)
    - 클라이언트가 서버와의 연결을 수립하기 위해 사용
    - addr의 서버와 연결을 시도, 해당 함수는 연결 성공할 때까지 블록되거나 에러 출력함
    - 연결에 성공하면 fd로 읽거나 쓸 수 있음
- bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
    - 서버가 클라이언트와 연결 수립하기 위해 사용
    - 커널에게 addr에 있는 서버 소켓 주소를 sockfd와 연결할 것을 요청
- listen(int sockfd, int backlog)
    - 기본적으로 능동적인 소켓(클라이언트용)이 socket 함수로 생성됨
    - 서버는 해당 함수 사용해 sockfd가 서버가 사용할 소켓이라는 걸 커널에 전달
    - 듣기 소켓은 클라이언트로부터의 요청을 accept할 수 있음
- accept(int listenfd, struct sockaddr *addr, int *addrlen)
    - 서버는 accept 함수 통해 클라이언트로부터의 연결 요청 기다림
    - accept 함수는 클라이언트의 연결 요청이 listenfd에 도달하기를 기다리며, 요청이 들어오면 addr에 클라이언트 소켓 주소를 채우며 클라이언트와의 통신에 쓸 **연결 식별자**를 리턴
    - 연결 식별자와 듣기 식별자듣기 식별자는 클라이언트 연결 요청에 대한 종단점, 보통 한 번 생성 후 서버 종료 시까지 유지, 연결 식별자는 클라이언트-서버 사이 연결 종단점. 서버가 연결 요청을 수락할 때마다 생성되며 서버가 해당 클라이언트에 서비스하는 동안에만 존재. 즉, bind와 listen으로 listenfd 작업해놓은 다음 accept가 그때그때 새로운 소켓 할당해주는 것
    *위 함수들 인자는 하드코딩 대신, getaddrinfo 등으로 생성하면 좋음

## **12. 동시성 프로그래밍**
논리 제어흐름이 시간적으로 중첩되면 동시적이며, 응용 수준에서 이를 가지면 동시성 프로그램
동시성 프로그램을 만드는 세가지 방법: 프로세스, I/O 다중화, 스레드
응용 수준의 동시성은 느린 I/O 디바이스 접근, I/O 인터페이스를 통한 유저와의 상호 교류, 작업 지연을 통한 딜레이 감소, 다수의 네트워크 클라이언트 처리, 멀티 코어 머신에서의 병령 계산 등에서 유용
### 12-1. 프로세스를 이용한 동시성 프로그래밍
- 예) 부모가 클라이언트 연결 요청을 수락하고, 자식 프로세스가 각 클라이언트를 서비스하는 경우
    - 이 경우 부모는 연결 식별자를, 자식은 듣기 식별자의 사본을 각각 닫아야함(leak 발생 방지)
    - 파일 테이블 엔트리 참조 횟수로 인해 connfd 사본이 모두 닫히기 전까지는 종료되지 않음
- 프로세스의 장단점
    - 파일 테이블은 공유되고 사용자 주소공간은 공유되지 않으므로 서로 간섭 안 줄 수 있음
    - 하지만 상태 정보 공유가 어려운데, 이를 위해 IPC 메커니즘 사용해야 함
        → 프로세스 제어와 IPC 오버헤드로 인해 조금 느릴 수 있음
### 12-2. I/O 다중화를 이용한 동시성 프로그래밍
- 예) 클라이언트 요청, 표준입력 등 여러 이벤트 모두에 대응해야하는 서버의 경우
- select 함수를 이용한 I/O 다중화 테크닉 적용
    - 커널에게 프로세스 정지 요청하고 한 개 이상의 I/O 이벤트 발생 시에만 제어를 돌려주게 함
    - ex) fd 집합에서 특정 fd가 읽기 혹은 쓰기 준비가 되면 리턴하는 식
    - fd 집합은 비트 벡터로 표현(비트 b_k는 식별자 k에 대응됨)
    - 간단하게, select 함수는 fd집합과 그 크기를 입력받아 그 집합 내에 최소 한 개의 fd가 읽을/쓸 준비가 될 때까지는 멈춰있음
        - select 호출 후 FD_ISSET 매크로를 이용해 각 준비된 fd에 대응하는 동작 서술
        - 읽기 집합은 select 호출 전마다 갱신 필요
    - obcli에서 사용 중
        - 근데 fd set이 지역변수인데다 표준입력밖에 안 받는데 굳이 왜 씀?
    - 한 프로세스 내에서 논리흐름이 복잡해지는 문제가 있어보임
### 12-3. 스레드를 이용한 동시성 프로그래밍
- 스레드는 프로세스 컨텍스트 내에서 돌아가는 논리흐름으로, 커널에 의해 자동으로 스케줄됨
- 각 스레드는 tid, 스택, pc, 레지스터 등을 포함하는 자신만의 컨텍스트를 가지며, 한 프로세스 내의 모든 스레드는 해당 프로세스의 전체 가상주소를 공유하며 동일한 고유 데이터를 읽고 쓸 수 있음
- Posix 스레드
    - C 프로그램에서 스레드를 조작하는 표준 인터페이스
- 스레드의 생성
    - pthread_create(pthread_t *tid, phtread_attr_t *attr, func *f, void *arg) 함수 사용
    - 새 스레드를 만들고 스레드 루틴 f를 새 스레드 컨텍스트 내에서 입력인자 arg 가지고 실행
    - attr 가지고 새로 생성되는 스레드 성질을 설정할 수 있는 듯함
    - 위 함수가 리턴할 때 tid는 새로 만들어진 스레드의 tid를 가짐
    - pthread_self 함수로 자신의 tid 확인 가능
- 스레드의 종료
    - 스레드는 자신의 최상위 스레드 루틴이 리턴할 때 묵시적으로 종료됨
    - pthread_exit(void *thread_return) 함수로 명시적 종료 가능
        - 메인 스레드가 호출하면 다른 모든 스레드의 종료를 기다린 후 메인스레드 및 전체 프로세스를 thread_return 값으로 종료
    - pthread_cancel(pthread_t tid)
        - 위 함수로 피어 스레드가 자신의 tid를 넘겨 현재 스레드 종료 가능
- 종료한 스레드 삭제
    - pthread_join(pthread_t tid, void **thread_return) 함수 사용
    - 스레드 tid가 종료할 때까지 멈춰있으며, 스레드 루틴이 리턴한 포인터를 thread_return이 가리키는 위치로 할당하고 종료된 스레드가 가지고 있던 모든 메모리 자원 삭제
- 스레드 분리하기
    - 스레드는 연결 가능하거나 분리되어있음
    - 연결 가능한 스레드는 다른 스레드에 의해 청소/종료될 수 있음 (스택 같은 메모리 자원은 다른 스레드에 의해 청소되기 전까지는 반환되지 않음)
    - 분리된 스레드는 다른 스레드로 청소 불가, 해당 스레드 종료 시 시스템에 의해 자동 반환됨
    - pthread_detach(pthread_t tid) 함수 사용
        - 기본적으로 스레드는 연결 가능하므로 해당 함수 사용하여 분리되어야함
- 스레드 초기화
    - pthread_once(pthread_once_t *once_control, void (*init_routine)(void)) 함수 사용
        - 스레드 루틴 관련 상태를 초기화할 수 있음
        - once_control 변수는 전연 변수로 항상 초기화되어 있음
        - 위 함수 호출하면 init_routine 호출
        - 동적으로 다수의 스레드에 의해 공유된 전역변수들을 초기화할 때 유용함
### 12.4 스레드 프로그램에서 공유 변수
- 경쟁상태(race)란?
    여러 프로세스/스레드가 공유 데이터를 읽고 쓸 때 실행 순서에 따라서 잘못된 값을 읽거나 쓰게 되는 상황
    스레드는 데이터 및 힙 영역 및 동일한 오픈된 파일들을 공유하므로 식별자 할당 등에 있어서는 주의 필요
- 변수들의 메모리 매핑
    - 전역 변수 : 런타임에 가상메모리의 읽기/쓰기 영역은 스레드에 의해 참조될 수 있는 각 전역 변수의 정확히 한 개 인스턴스를 포함
    - 지역 자동 변수 : 각 스레드의 스택은 런타임에 자신만의 지역 자동 변수의 인스턴스를 가짐
    - 지역 정적 변수 : 전역 변수처럼 한 개 인스턴스가 존재
- 변수는 자신의 인스턴스 중 한 개가 하나 이상의 스레드에 의해 참조되는 경우에만 공유되어 있다고 할 수 있음 (지역 자동 변수도 공유될 수는 있음에 유의)
### 12.5 세마포어로 스레드 동기화
- OS가 스레드를 위해 정확한 순서를 선택해줄 지 여부를 예측할 방법은 없음
- 세마포어
    - 세마포어 s는 비음수 정수 값을 갖는 전역변수로 특별한 두 연산(P,V)으로만 조작됨
    - P(s)
        - s가 0이 아니면 s를 감소시키고 즉시 리턴
        - s가 0이면 스레드는 s가 0이 아닌 값을 가지고, 스레드가 V 연산에 의해 재시작될 때까지 정지됨. 재시작 후에 P는 s를 감소시키고 제어를 호출자에게 돌려줌
    - V(s)
        - s를 1 증가시킴. 만약 P 연산에서 멈춰있는 스레드가 있는 경우, V는 그 스레드 중 한 스레드를 시작하고, 그 후 s가 감소되며 P 연산이 완료됨
    - POSIX에서는 sem_init(), sem_wait(), sem_post()로 구현됨
- 바이너리 세마포어를 통해 mutex를 구현할 수 있음
    - 임계영역을 P와 V 연산으로 둘러싸는 방법 등
- 공유자원의 스케줄링
    - 생산자-소비자 문제
        - 단순히 배타성을 부여하는 것 뿐만 아니라 블로킹 큐 같은 기능도 고려
    - 읽기-쓰기 문제
### 12.6 다른 동시성의 이슈
- 스레드 안전성
    - 어떤 함수가 다수의 동시성 스레드로부터 반복적으로 호출되어도 정확한 결과를 만드는 경우에만 스레드 안전하다고 함
    - 스레드 위험한 함수의 네가지 경우(중첩될 수 있음)
        - 공유 변수를 보호하지 않는 경우
        - 다중 호출에 대해 상태를 유지하는 함수 (ex. 현재 호출 결과가 이전 결과에 의존)
        - 정적변수를 가리키는 포인터를 리턴하는 함수
            → 한 스레드가 사용하는 결과가 다른 스레드에 의해 덮어써질 우려가 있음
        - 스레드 위험 함수를 호출하는 함수
            → 여러 케이스 존재
- 재진입성
    - 스레드 안전 함수의 한 클래스, 호출 순서 등 상관없이 언제나 동일 결과 보장
    - 다수의 스레드에 의해 호출되어도 공유 데이터는 전혀 참조하지 않는 특성
    - 리눅스에서 스레드 위험한 함수의 재진입 가능 버전은 _r 접미사로 끝남
        - 되도록 표준 라이브러리에서 안전한 함수 사용하는 것이 좋음
- 교착상태 조심